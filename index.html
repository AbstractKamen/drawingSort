<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sort Drawing</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
    <script src="sorts.js"></script>
    <script src="sort_drawing.js"></script>
    <link rel="icon" href="data:,">
</head>

<body>
    <ol id="sorts">
        <li>
            <div class="btns"><b>Sleep Sort</b><br>
                <button id="sort-sleep-btn" class="sort-btn">Sort</button>
                <button id="reset-sleep-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Not Stable, O(n) time complexity</strong></p>
                        <p> A rather unconventional sorting algorithm that exploits the concept of time
                            delays or "sleeping" to sort a list of numbers.
                            For each number in the input list, create a separate thread, task, or process.
                            In each thread, set a timer or delay that is proportional to the value of the number being
                            sorted.
                            For example, if a number is 5, the thread will sleep for 5 units of time.
                            When all threads have finished sleeping, collect the numbers in the order in which they woke
                            up.
                            This order will be a sorted sequence.
                            Sleep Sort is a fun and intriguing concept but is not suitable for practical sorting tasks
                            due to
                            its inefficiency and reliance on multithreading or asynchronous operations. It's mainly used
                            as an educational or recreational algorithm to demonstrate the idea of concurrency and
                            timing.
                        <p>Due to the unstable nature of this algorithm and the way "super speed" is implemented it will
                            almost always fail to sort large lists.</p>
                        <p><b>It also can't handle negative values!</b></p>
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-sleep-btn">Colour Mode</button><br>
                <button id="tgl-numbers-sleep-btn">View Numbers</button><br>

                <input id="sleep-range" type="range" min="0" max="100" value="0" class="slider">Numbers Range</input>
                <input id="sleep-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>
                <input id="sleep-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="sleep-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns"><b>Quick Sort</b><br>
                <button id="sort-quick-btn" class="sort-btn">Sort</button>
                <button id="reset-quick-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Not Stable, In place, O(n log n) time complexity</strong></p>
                        <p> A highly efficient and widely used sorting algorithm known for its
                            average-case performance.
                            It begins by choosing a "pivot" element from the array. The choice of the pivot can be
                            random or deterministic (in the example the pivot is the length of the subarray -1).
                            Rearrange the elements in the
                            array such that all elements less than the pivot are
                            on the left side, and all elements greater than the pivot are on the right side. The pivot
                            itself is in its final sorted position. Recursively apply the Quick Sort algorithm to the
                            subarrays formed on the left and right sides of the pivot until the entire array is
                            sorted.No additional combining step is
                            needed because the array is sorted in place.
                            Quick Sort is efficient because, on average, it has a time complexity of O(n log n), where
                            "n" is
                            the number of elements to be sorted. It has good cache performance and can be implemented in
                            a way
                            that uses relatively little additional memory. However, its worst-case time complexity is
                            O(n^2) if the pivot selection and partitioning are not well-balanced, making it important to
                            choose pivots wisely or use randomized pivot selection to avoid worst-case scenarios.
                        <p>In the example you can see the worst case if you try to sort an already sorted array.</p>
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-quick-btn">Colour Mode</button><br>
                <button id="tgl-numbers-quick-btn">View Numbers</button><br>
                <input id="quick-range" type="range" min="0" max="100" value="0" class="slider">Numbers Range</input>
                <input id="quick-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>
                <input id="quick-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="quick-sort" class="sort">
            </div>
        </li>
        <li>
            <div class="btns"><b>Iterative Quick Sort</b><br>
                <button id="sort-iterative-quick-btn" class="sort-btn">Sort</button>
                <button id="reset-iterative-quick-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Not Stable, Not In place, O(n log n) time complexity</strong></p>
                        <p>An iterative implementation of the Quick Sort algorithm with the help of a stack data
                            structure.</p>
                        <p>Since we are not using recursion the algorithm starts from the end.</p>
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-iterative-quick-btn">Colour Mode</button><br>
                <button id="tgl-numbers-iterative-quick-btn">View Numbers</button><br>
                <input id="iterative-quick-range" type="range" min="0" max="100" value="0" class="slider">Numbers
                Range</input>
                <input id="iterative-quick-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>
                <input id="iterative-quick-elements-range" type="range" min="15" max="1200" value="40"
                    class="slider">Array Size</input>
            </div>
            <div id="iterative-quick-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns">
                <b>Merge Sort</b><br>
                <button id="sort-merge-btn" class="sort-btn">Sort</button>
                <button id="reset-merge-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Stable, Not In place, O(n log n) time complexity</strong></p>
                        <p>A widely used and efficient comparison-based sorting algorithm known for its
                            stability and guaranteed time complexity. It uses the 'divide and conquer' approach and is
                            typically recursive. Begin by taking the unsorted list and split it into two roughly equal
                            halves. This division continues recursively until each sublist contains just one element,
                            which is considered already sorted. The individual sublists are then merged back together,
                            and during this
                            merging process, the elements are sorted. This is done by comparing the elements from the
                            two sublists and
                            placing them in sorted order. The merging step continues until a single sorted list remains,
                            containing
                            all the elements from the original unsorted list. Merge Sort is highly efficient and stable,
                            meaning that no matter what the dataset is (almost sorted, sorted, random, etc.) the time
                            complexity will still be O(n log n) and the order of equal elements before and after sorting
                            is guaranteed to remain the same. It's often used as the basis for other sorting
                            algorithms and is a fundamental concept in computer science.
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-merge-btn">Colour Mode</button><br>
                <button id="tgl-numbers-merge-btn">View Numbers</button><br>

                <input id="merge-range" type="range" min="0" max="100" value="0" class="slider">Numbers Range</input>
                <input id="merge-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>
                <input id="merge-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="merge-sort" class="sort">
            </div>
        </li>
        <li>
            <div class="btns">
                <b>Iterative (unoptimised) Merge Sort</b><br>
                <button id="sort-iterative-merge-btn" class="sort-btn">Sort</button>
                <button id="reset-iterative-merge-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Stable, Not In place, O(n log n) time complexity</strong></p>
                        <p>Iterative Merge Sort is an alternative implementation of the traditional Merge Sort algorithm
                            that avoids recursion and instead uses an iterative approach. It is a comparison-based
                            sorting algorithm that divides the input array into smaller subarrays, sorts them, and then
                            merges the sorted subarrays to produce a fully sorted array. Unlike the recursive version of
                            Merge Sort, the unoptimised iterative version uses a second auxiliary array, to perform the
                            merging. With an auxiliary array, the space complexity is O(n), but it can be optimized to
                            O(1) with in-place merging.
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-iterative-merge-btn">Colour Mode</button><br>
                <button id="tgl-numbers-iterative-merge-btn">View Numbers</button><br>

                <input id="iterative-merge-range" type="range" min="0" max="100" value="0" class="slider">Numbers
                Range</input>
                <input id="iterative-merge-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>
                <input id="iterative-merge-elements-range" type="range" min="15" max="1200" value="40"
                    class="slider">Array
                Size</input>
            </div>
            <div id="iterative-merge-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns"><b>Heap Sort</b><br>
                <button id="sort-heap-btn" class="sort-btn">Sort</button>
                <button id="reset-heap-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Not Stable, In place, O(n log n) time complexity</strong></p>
                        <p>An efficient comparison-based sorting algorithm that operates by transforming
                            an input array into a binary heap data structure and then repeatedly extracting the maximum
                            (for the
                            current max-heap example) element from the heap, placing it at the end of the array, and
                            adjusting the heap to maintain its properties.
                            The algorithm starts by building a heap from the given input array. This is done by
                            iterating through the array from the bottom up and ensuring that the heap property is
                            maintained at
                            each step. For a max-heap, this means that the parent node is greater than or equal to its
                            child
                            nodes. After the heap is built, the largest element is at
                            the root of the heap (index 0). Swap this element with the last element in the array. This
                            effectively moves the maximum element to its correct sorted position at the end of the
                            array. To maintain the heap property, heapify the remaining elements in the heap. This
                            involves
                            moving the new root element down the tree until the heap property is restored.

                            Heap Sort has a time complexity of O(n log n) for worst-case, average-case, and best-case
                            scenarios.
                            It's an in-place, stable, and comparison-based sorting algorithm, making it a reliable
                            choice for
                            sorting large datasets. However, it's less commonly used in practice compared to algorithms
                            like
                            Quick Sort or Merge Sort for most scenarios due to its slightly higher overhead.
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-heap-btn">Colour Mode</button><br>
                <button id="tgl-numbers-heap-btn">View Numbers</button><br>

                <input id="heap-range" type="range" min="0" max="100" value="0" class="slider">Numbers Range</input>

                <input id="heap-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort Speed</input>

                <input id="heap-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="heap-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns"><b>Bubble Sort</b><br>
                <button id="sort-bubble-btn" class="sort-btn">Sort</button>
                <button id="reset-bubble-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Stable, In place, O(n^2) time complexity</strong></p>
                        <p> A simple and easy to understand sorting algorithm. It repeatedly iterates
                            through the list to be sorted, compares adjacent elements, and swaps them if they are in the
                            wrong order. Starting at the beginning of the list.
                            Compare the first two elements. If the first element is larger (in the context of sorting in
                            ascending order), swap them.
                            Move one position to the right and repeat for the next pair of elements.
                            Continue this process, comparing and swapping adjacent elements as needed, until you reach
                            the end of the list.
                            After one pass through the list, the largest unsorted element will have "bubbled up" to the
                            end of the list.
                            Continue these passes until no more swaps are needed, indicating that the entire list is
                            sorted.
                            Bubble Sort is straightforward to understand and implement, but it is generally inefficient
                            for large lists, especially when compared to more advanced sorting algorithms like Merge
                            Sort or Quick Sort. It has a time complexity of O(n^2) in the worst case, where n is the
                            number of elements in the list, making it less suitable for large datasets.
                        <p>An 'optimised' version of bubble sort has O(n) time complexity if the dataset is already
                            sorted.</p>
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-bubble-btn">Colour Mode</button><br>
                <button id="tgl-numbers-bubble-btn">View Numbers</button><br>

                <input id="bubble-range" type="range" min="0" max="100" value="0" class="slider">Numbers Range</input>
                <input id="bubble-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>
                <input id="bubble-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="bubble-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns"><b>Brick Sort</b><br>
                <button id="sort-brick-btn" class="sort-btn">Sort</button>
                <button id="reset-brick-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Stable, In place, O(n^2) time complexity</strong></p>
                        Brick Sort, also known as Odd-Even Sort, is a sorting algorithm that builds upon the principles
                        of the Bubble Sort but with improved performance. It is named "Brick Sort" because it resembles
                        the process of arranging bricks in a wall. The algorithm divides the list into two parts: the
                        odd elements and the even elements. It then repeatedly compares and swaps adjacent pairs
                        of elements within each part to sort the entire list.
                        <p>The worst-case time complexity of Brick Sort is O(n^2), where n is the number of elements in
                            the list. This makes it less efficient than some other sorting algorithms for large lists.
                            However, its performance can be improved by adding early termination checks to detect sorted
                            or nearly sorted lists.
                        </p>
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-brick-btn">Colour Mode</button><br>
                <button id="tgl-numbers-brick-btn">View Numbers</button><br>

                <input id="brick-range" type="range" min="0" max="100" value="0" class="slider">Numbers Range</input>
                <input id="brick-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>
                <input id="brick-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="brick-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns"><b>Shaker Sort</b><br>
                <button id="sort-shaker-btn" class="sort-btn">Sort</button>
                <button id="reset-shaker-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Stable, In place, O(n^2) time complexity</strong></p>
                        <p> Shaker Sort, also known as Cocktail Sort, is a variation of the bubble sort algorithm. It
                            does it's sorting by moving the largest value to the end of the list. Then when it reaches
                            the end instead of starting over like bubble sort it starts going back to the beginning this
                            time moving the smallest value it finds. It keeps doing this until no swaps have occurred
                            and the list is sorted. The shaker sort has the bubble sort optimisation for sorting an
                            already sorted list. It is also slightly faster than the normal bubble sort time but it's
                            worst case is still O(n^2).
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-shaker-btn">Colour Mode</button><br>
                <button id="tgl-numbers-shaker-btn">View Numbers</button><br>

                <input id="shaker-range" type="range" min="0" max="100" value="0" class="slider">Numbers Range</input>
                <input id="shaker-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>
                <input id="shaker-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="shaker-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns"><b>Comb Sort</b><br>
                <button id="sort-comb-btn" class="sort-btn">Sort</button>
                <button id="reset-comb-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Not Stable, In place, O(n^2) time complexity</strong></p>
                        <p>Comb Sort is a comparison-based sorting algorithm that improves upon the Bubble Sort
                            algorithm by eliminating or reducing the number of small values at the end of the list
                            quickly.
                            Initialize a gap (initially a large value) that determines the distance between elements to
                            be compared and swapped. Commonly, the gap is set to a value slightly less than the length
                            of the list.
                            Iterate through the list, comparing elements that are separated by the current gap value. If
                            two elements are out of order, swap them.
                            Reduce the gap size (commonly by a fixed reduction factor, often around 1.3) and repeat the
                            comparisons and swaps until the gap becomes 1.
                            Continue the process with a gap of 1, which is essentially performing a final pass of Bubble
                            Sort to ensure the remaining small elements "bubble" to their correct positions.
                            Comb Sort's name comes from the idea of "combing" through the list with decreasing gap
                            sizes. While it is not the most efficient sorting algorithm, it is an improvement over
                            Bubble Sort and is simple to understand and implement. It has an average-case time
                            complexity of O(n^2), but its performance can be improved with certain variations and
                            optimizations.
                        <p>An 'optimised' version of bubble sort has O(n) time complexity if the dataset is already
                            sorted.</p>
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-comb-btn">Colour Mode</button><br>
                <button id="tgl-numbers-comb-btn">View Numbers</button><br>

                <input id="comb-range" type="range" min="0" max="100" value="0" class="slider">Numbers Range</input>

                <input id="comb-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort Speed</input>

                <input id="comb-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="comb-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns"><b>Insertion Sort</b><br>
                <button id="sort-insertion-btn" class="sort-btn">Sort</button>
                <button id="reset-insertion-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Stable, In place, O(n^2) time complexity</strong></p>
                        <p>
                            Insertion Sort is a simple and efficient comparison-based sorting algorithm.
                            Start with the second element (index 1) of the array. This element is assumed to be part of
                            the sorted portion of the array.
                            Compare the second element with the one before it (the first element) and move the second
                            element to its correct position within the sorted portion of the array. If the second
                            element is smaller, swap it with the first element.
                            Move on to the third element (index 2) and repeat the process, shifting it leftwards within
                            the sorted portion until it is in its correct position relative to the already sorted
                            elements.
                            Continue this process for each subsequent element in the array, one at a time, until the
                            entire array is sorted.
                        <p>Insertion Sort is an in-place sorting algorithm, meaning it doesn't require additional
                            memory for sorting, and it works well for small to moderately sized lists. However, its time
                            complexity is O(n^2) in the worst case, making it less efficient than some other sorting
                            algorithms for large lists.</p>
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-insertion-btn">Colour Mode</button><br>
                <button id="tgl-numbers-insertion-btn">View Numbers</button><br>

                <input id="insertion-range" type="range" min="0" max="100" value="0" class="slider">Numbers
                Range</input>

                <input id="insertion-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>

                <input id="insertion-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="insertion-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns"><b>Shell Sort</b><br>
                <button id="sort-shell-btn" class="sort-btn">Sort</button>
                <button id="reset-shell-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Not Stable, In place, O(n^2) time complexity</strong></p>
                        <p>
                            Shell Sort is an advanced sorting algorithm designed to improve upon the basic insertion
                            sort method. It operates by dividing the input data into smaller chunks, and applies
                            insertion sort separately to each of them. These chunks are created by selecting elements at
                            fixed intervals or gaps. The key innovation in Shell Sort is the gradual reduction of these
                            intervals, leading to a more sorted state before the final pass.<br>
                            The algorithm begins with a relatively large gap between elements, making it efficient for
                            moving smaller values to the beginning of the array and larger values to the end. This
                            initial step helps reduce the overall work required for subsequent sorting passes. As the
                            algorithm progresses, the gap decreases (by factor of 2.3 in this example), eventually
                            reaching a value of 1, at which point Shell Sort behaves similarly to the traditional
                            insertion sort.<br>
                            By employing this step-by-step approach, Shell Sort capitalizes on the advantages of
                            insertion sort for partially sorted subarrays, significantly improving sorting efficiency.
                            While it doesn't guarantee the optimal time complexity, Shell Sort provides a practical
                            balance between simplicity and performance, making it a valuable sorting method for various
                            applications.
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-shell-btn">Colour Mode</button><br>
                <button id="tgl-numbers-shell-btn">View Numbers</button><br>

                <input id="shell-range" type="range" min="0" max="100" value="0" class="slider">Numbers Range</input>

                <input id="shell-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>

                <input id="shell-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="shell-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns"><b>Selection Sort</b><br>
                <button id="sort-selection-btn" class="sort-btn">Sort</button>
                <button id="reset-selection-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Not Stable, In place, O(n^2) time complexity</strong></p>
                        <p>Selection Sort is a simple comparison-based sorting algorithm that works by repeatedly
                            selecting the smallest element from an unsorted portion of the list and moving
                            it to the beginning of the sorted portion. Initially, the sorted part is empty, and the
                            unsorted part contains all elements. Iterate through the whole unsorted part and find the
                            smallest. Swap this smallest element with the leftmost element in the unsorted part,
                            effectively moving it to the sorted part. Expand the sorted part by one element, and reduce
                            the unsorted part by one element.
                        <p>Selection Sort is easy to understand and implement but is not the most efficient sorting
                            algorithm as it has a time complexity of O(n^2).
                            It is mainly used for educational purposes or for small lists where simplicity is more
                            important than performance.</p>
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-selection-btn">Colour Mode</button><br>
                <button id="tgl-numbers-selection-btn">View Numbers</button><br>

                <input id="selection-range" type="range" min="0" max="100" value="0" class="slider">Numbers
                Range</input>
                <input id="selection-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>
                <input id="selection-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="selection-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns"><b>Circle Sort</b><br>
                <button id="sort-circle-btn" class="sort-btn">Sort</button>
                <button id="reset-circle-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Not Stable, In place, O(n^2) time complexity</strong></p>
                        <p>
                            Circle Sort, also known as Cycle Sort, is an in-place and unstable sorting algorithm
                            designed to minimize the number of writes to memory. It is particularly useful for
                            situations where write operations are expensive or limited. Circle Sort works by selecting
                            an element from the unsorted portion of the array and repeatedly cycling it to its correct
                            position, effectively building a sorted sequence one element at a time.
                        </p>
                        <p>Circle Sort selects an element from the unsorted portion of the array and cycles it through
                            its correct position in the sorted portion. This process continues until all elements are in
                            their correct positions. To cycle an element to its correct position, the algorithm detects
                            cycles within the array. A cycle is a set of elements where each element's final position is
                            occupied by another element in the cycle. Once all cycles are identified it cycles the
                            elements within each cycle until they reach their correct positions. This process is
                            repeated for each unsorted element until the entire array is sorted. The algorithm keeps
                            track of the sorted portion and the remaining unsorted portion.</p>
                    </div>
                </button>
                <button id="tgl-colour-mode-circle-btn">Colour Mode</button><br>
                <button id="tgl-numbers-circle-btn">View Numbers</button><br>

                <input id="circle-range" type="range" min="0" max="100" value="0" class="slider">Numbers
                Range</input>
                <input id="circle-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>
                <input id="circle-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="circle-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns"><b>Patience Sort</b><br>
                <button id="sort-patience-btn" class="sort-btn">Sort</button>
                <button id="reset-patience-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Stable, Not In place, O(n^2) time complexity</strong>
                        <p>Patience Sort is a sorting algorithm inspired by the patience card game. It is used to
                            efficiently sort a sequence of elements, typically represented as a deck of cards, by
                            creating piles of cards following specific rules and then merging these piles to obtain the
                            sorted sequence. Patience Sort is known for its simplicity and effectiveness, especially in
                            scenarios where the number of elements is moderate, but the input data is not fully sorted.
                            It's an adaptive algorithm, making it efficient for partially sorted lists. It's also a
                            stable sorting algorithm, meaning that it preserves the relative order of equal elements.
                        </p>
                        <p>Initialization: Start with an empty array of piles and iterate through the elements to be
                            sorted.</p>

                        <p>Pile Creation: For each element, find the leftmost pile where it can be placed on top
                            according to the sorting order. If no such pile exists, create a new pile with the
                            element.</p>
                        <p>Merging Piles: Once all elements are placed into piles, merge them to obtain the
                            sorted sequence. This typically involves using a min-heap data structure. During merging,
                            the top card of each pile is compared, and the smallest card is added to the sorted
                            sequence. The pile from which the card was removed is refilled with the next card, and this
                            process continues until all cards are merged. The result of the merging
                            process is a sorted sequence of elements.</p>

                        <p>Complexity: The algorithm has a time complexity of O(n * log n),
                            where n is the number of elements to be sorted. The most time-consuming step is merging the
                            piles. The space complexity is O(n) because it requires extra space to
                            store the piles.</p>
                        <p>Patience Sort is rarely used in practical applications due to
                            its space and time complexities. However, it serves as an interesting algorithmic concept
                            and is used as a benchmark in sorting algorithm analysis.</p>
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-patience-btn">Colour Mode</button><br>
                <button id="tgl-numbers-patience-btn">View Numbers</button><br>

                <input id="patience-range" type="range" min="0" max="100" value="0" class="slider">Numbers Range</input>
                <input id="patience-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>
                <input id="patience-elements-range" type="range" min="15" max="1200" value="40" class="slider">Array
                Size</input>
            </div>
            <div id="patience-sort" class="sort">
            </div>
        </li>

        <li>
            <div class="btns"><b>Comb-Insertion Sort</b><br>
                <button id="sort-comb-insertion-btn" class="sort-btn">Sort</button>
                <button id="reset-comb-insertion-btn">Clear</button>
                <button class="collapsible">Click for description
                    <div class="collapsible-content">
                        <p>Characteristics:<strong> Not Stable, In place, O(n^2) time complexity</strong></p>
                        <p>Comb-Insertion Hybrid Sort is a sorting algorithm that combines two different sorting
                            techniques, namely Comb Sort and Insertion Sort, to achieve improved performance for certain
                            types of input data. The Comb-Insertion Hybrid Sort algorithm combines the two approaches.
                            It
                            starts with Comb Sort to quickly reduce the distance between elements, and when the gap
                            becomes small (7 in the example), it switches to Insertion Sort. This
                            hybridization leverages the strengths of Comb Sort for initial gap reduction and Insertion
                            Sort for final fine-grained sorting.
                            The advantage of this hybrid approach is that it can take advantage of Comb Sort's
                            efficiency in handling larger gaps and Insertion Sort's efficiency in handling smaller gaps,
                            making it a potentially faster sorting algorithm compared to using either method in
                            isolation, especially for lists that are partially sorted or have elements with varying
                            magnitudes.
                        </p>
                    </div>
                </button>
                <button id="tgl-colour-mode-comb-insertion-btn">Colour Mode</button><br>
                <button id="tgl-numbers-comb-insertion-btn">View Numbers</button><br>

                <input id="comb-insertion-range" type="range" min="0" max="100" value="0" class="slider">Numbers
                Range</input>
                <input id="comb-insertion-millis-range" type="range" min="-9" max="50" value="0" class="slider">Sort
                Speed</input>
                <input id="comb-insertion-elements-range" type="range" min="15" max="1200" value="40"
                    class="slider">Array Size</input>
            </div>
            <div id="comb-insertion-sort" class="sort">
            </div>
        </li>
    </ol>
</body>

</html>